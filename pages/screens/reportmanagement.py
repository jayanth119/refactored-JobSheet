import sys 
import os 
import pandas as pd 
import streamlit as st
from datetime import datetime, timedelta
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from components.datamanager.databasemanger import DatabaseManager
from components.report.adminanalytics import admin_analytics
from components.report.manageranalytics import manager_analytics
from components.report.techniciananalytics import technician_analytics
import io 
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas

def validate_numeric_data(df, numeric_columns):
    """Ensure specified columns are numeric, converting if necessary"""
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    return df


def reports_management():
    user = st.session_state.user
    
    # Role-based access control
    if user['role'] == 'staff':
        st.error("üö´ Access Denied: Staff members don't have access to analytics and reports.")
        st.info("Please contact your manager or admin for access to reports.")
        return
    
    st.markdown(f'''
        <div class="main-header">
            <h1>üìä Business Analytics & Reports</h1>
            <p>Comprehensive business analysis based on your role: {user['role'].title()}</p>
        </div>
    ''', unsafe_allow_html=True)
    
    db = DatabaseManager()
    conn = db.get_connection()
    
    # Date range selector
    col1, col2 = st.columns(2)
    with col1:
        start_date = st.date_input("Start Date", value=datetime.now() - timedelta(days=30))
    with col2:
        end_date = st.date_input("End Date", value=datetime.now())
    
    # Convert dates to strings for SQL query
    start_date_str = start_date.strftime('%Y-%m-%d')
    end_date_str = end_date.strftime('%Y-%m-%d')
    
    selected_store = None
    
    # Role-based analytics
    if user['role'] == 'admin':
        admin_analytics(conn, start_date_str, end_date_str, user)
        # Get selected store for export
        stores = pd.read_sql("SELECT id, name FROM stores", conn)
        store_options = dict(zip(stores['name'], stores['id']))
        selected_store = st.session_state.get('selected_store', "All Stores")
        
    elif user['role'] == 'manager':
        manager_analytics(conn, start_date_str, end_date_str, user)
        
    elif user['role'] == 'technician':
        technician_analytics(conn, start_date_str, end_date_str, user)
    
    # Add export functionality
    add_export_functionality(conn, user, start_date_str, end_date_str, selected_store)
    
    conn.close()




def export_comprehensive_report(conn, user, start_date_str, end_date_str, selected_store=None):
    """Export comprehensive business report as PDF"""
    
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    
    # Header
    c.setFont("Helvetica-Bold", 20)
    c.drawString(50, height - 50, "RepairPro Business Analytics Report")
    
    c.setFont("Helvetica", 12)
    c.drawString(50, height - 80, f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    c.drawString(50, height - 100, f"Report Period: {start_date_str} to {end_date_str}")
    c.drawString(50, height - 120, f"Generated by: {user.get('full_name', 'Unknown')} ({user['role'].title()})")
    
    if selected_store and selected_store != "All Stores":
        c.drawString(50, height - 140, f"Store: {selected_store}")
        y_position = height - 170
    else:
        y_position = height - 150
    
    # Role-specific content
    if user['role'] == 'admin':
        # Get summary statistics for admin
        where_clause = "j.created_at BETWEEN ? AND ?"
        params = [start_date_str, end_date_str]
        
        summary_query = f"""
            SELECT 
                COUNT(*) as total_jobs,
                SUM(CASE WHEN status = 'Completed' THEN 1 ELSE 0 END) as completed_jobs,
                SUM(CASE WHEN status = 'Completed' THEN actual_cost ELSE 0 END) as total_revenue,
                COUNT(DISTINCT store_id) as active_stores,
                COUNT(DISTINCT customer_id) as unique_customers
            FROM jobs j
            WHERE {where_clause}
        """
        
        summary = pd.read_sql(summary_query, conn, params=params).iloc[0]
        
        c.setFont("Helvetica-Bold", 14)
        c.drawString(50, y_position, "Executive Summary")
        y_position -= 30
        
        c.setFont("Helvetica", 11)
        c.drawString(70, y_position, f"‚Ä¢ Total Jobs Processed: {summary['total_jobs']:,}")
        y_position -= 20
        c.drawString(70, y_position, f"‚Ä¢ Jobs Completed: {summary['completed_jobs']:,}")
        y_position -= 20
        
        revenue = summary['total_revenue'] if summary['total_revenue'] else 0
        c.drawString(70, y_position, f"‚Ä¢ Total Revenue: ‚Çπ{revenue:,.2f}")
        y_position -= 20
        c.drawString(70, y_position, f"‚Ä¢ Active Stores: {summary['active_stores']:,}")
        y_position -= 20
        c.drawString(70, y_position, f"‚Ä¢ Unique Customers: {summary['unique_customers']:,}")
        y_position -= 40
        
        # Completion rate
        completion_rate = (summary['completed_jobs'] / summary['total_jobs'] * 100) if summary['total_jobs'] > 0 else 0
        c.drawString(70, y_position, f"‚Ä¢ Overall Completion Rate: {completion_rate:.1f}%")
        y_position -= 40
        
    elif user['role'] == 'manager':
        # Manager-specific summary
        where_clause = "j.created_at BETWEEN ? AND ? AND j.store_id = ?"
        params = [start_date_str, end_date_str, user['store_id']]
        
        store_summary_query = f"""
            SELECT 
                COUNT(*) as total_jobs,
                SUM(CASE WHEN status = 'Completed' THEN 1 ELSE 0 END) as completed_jobs,
                SUM(CASE WHEN status = 'Completed' THEN actual_cost ELSE 0 END) as total_revenue,
                COUNT(DISTINCT customer_id) as unique_customers
            FROM jobs j
            WHERE {where_clause}
        """
        
        summary = pd.read_sql(store_summary_query, conn, params=params).iloc[0]
        
        c.setFont("Helvetica-Bold", 14)
        c.drawString(50, y_position, "Store Performance Summary")
        y_position -= 30
        
        c.setFont("Helvetica", 11)
        c.drawString(70, y_position, f"‚Ä¢ Store Jobs: {summary['total_jobs']:,}")
        y_position -= 20
        
        revenue = summary['total_revenue'] if summary['total_revenue'] else 0
        c.drawString(70, y_position, f"‚Ä¢ Store Revenue: ‚Çπ{revenue:,.2f}")
        y_position -= 20
        c.drawString(70, y_position, f"‚Ä¢ Store Customers: {summary['unique_customers']:,}")
        y_position -= 40
        
    elif user['role'] == 'technician':
        # Technician-specific summary
        tech_summary_query = f"""
            SELECT 
                COUNT(DISTINCT aj.job_id) as jobs_handled,
                COUNT(DISTINCT ta.id) as total_assignments,
                SUM(CASE WHEN ta.status = 'completed' THEN 1 ELSE 0 END) as completed_assignments,
                SUM(CASE WHEN j.status = 'Completed' THEN j.actual_cost ELSE 0 END) as revenue_generated
            FROM technician_assignments ta
            JOIN assignment_jobs aj ON ta.id = aj.assignment_id
            JOIN jobs j ON aj.job_id = j.id
            WHERE ta.technician_id = ? AND ta.assigned_at BETWEEN ? AND ?
        """
        
        summary = pd.read_sql(tech_summary_query, conn, 
                             params=[user['id'], start_date_str, end_date_str]).iloc[0]
        
        c.setFont("Helvetica-Bold", 14)
        c.drawString(50, y_position, "Personal Performance Summary")
        y_position -= 30
        
        c.setFont("Helvetica", 11)
        c.drawString(70, y_position, f"‚Ä¢ Jobs Handled: {summary['jobs_handled']:,}")
        y_position -= 20
        c.drawString(70, y_position, f"‚Ä¢ Assignments Completed: {summary['completed_assignments']:,}")
        y_position -= 20
        
        revenue = summary['revenue_generated'] if summary['revenue_generated'] else 0
        c.drawString(70, y_position, f"‚Ä¢ Revenue Generated: ‚Çπ{revenue:,.2f}")
        y_position -= 40
    
    # Add device analytics section
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, y_position, "Device Analytics")
    y_position -= 30
    
    # Get device type distribution
    if user['role'] == 'admin':
        device_query = "SELECT device_type, COUNT(*) as count FROM jobs j WHERE j.created_at BETWEEN ? AND ? GROUP BY device_type ORDER BY count DESC LIMIT 5"
        device_params = [start_date_str, end_date_str]
    elif user['role'] == 'manager':
        device_query = "SELECT device_type, COUNT(*) as count FROM jobs j WHERE j.created_at BETWEEN ? AND ? AND j.store_id = ? GROUP BY device_type ORDER BY count DESC LIMIT 5"
        device_params = [start_date_str, end_date_str, user['store_id']]
    else:  # technician
        device_query = """
            SELECT j.device_type, COUNT(*) as count 
            FROM jobs j
            JOIN assignment_jobs aj ON j.id = aj.job_id
            JOIN technician_assignments ta ON aj.assignment_id = ta.id
            WHERE ta.technician_id = ? AND ta.assigned_at BETWEEN ? AND ?
            GROUP BY j.device_type ORDER BY count DESC LIMIT 5
        """
        device_params = [user['id'], start_date_str, end_date_str]
    
    device_data = pd.read_sql(device_query, conn, params=device_params)
    
    c.setFont("Helvetica", 11)
    c.drawString(70, y_position, "Top Device Types:")
    y_position -= 20
    
    for _, row in device_data.iterrows():
        c.drawString(90, y_position, f"‚Ä¢ {row['device_type']}: {row['count']} jobs")
        y_position -= 15
    
    # Footer
    c.setFont("Helvetica-Italic", 10)
    c.drawString(50, 50, "This report is generated automatically by RepairPro Analytics System")
    c.drawString(50, 35, f"For questions or support, contact your system administrator")
    
    c.save()
    buffer.seek(0)
    
    return buffer

def add_export_functionality(conn, user, start_date_str, end_date_str, selected_store=None):
    """Add export functionality to the analytics dashboard"""
    
    st.markdown("---")
    st.markdown("### üìÑ Export Reports")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üìä Export Analytics Report"):
            try:
                pdf_buffer = export_comprehensive_report(conn, user, start_date_str, end_date_str, selected_store)
                
                filename = f"RepairPro_Analytics_{user['role']}_{start_date_str}_to_{end_date_str}.pdf"
                
                st.success("‚úÖ Report generated successfully!")
                st.download_button(
                    label="‚¨áÔ∏è Download PDF Report",
                    data=pdf_buffer,
                    file_name=filename,
                    mime="application/pdf",
                    key="analytics_report"
                )
            except Exception as e:
                st.error(f"Error generating report: {str(e)}")
    
    with col2:
        if st.button("üìà Export Raw Data (CSV)"):
            try:
                # Export relevant data based on user role
                if user['role'] == 'admin':
                    export_query = """
                        SELECT j.*, c.name as customer_name, c.phone as customer_phone, 
                               s.name as store_name, s.location as store_location
                        FROM jobs j
                        LEFT JOIN customers c ON j.customer_id = c.id
                        LEFT JOIN stores s ON j.store_id = s.id
                        WHERE j.created_at BETWEEN ? AND ?
                        ORDER BY j.created_at DESC
                    """
                    export_params = [start_date_str, end_date_str]
                    
                elif user['role'] == 'manager':
                    export_query = """
                        SELECT j.*, c.name as customer_name, c.phone as customer_phone
                        FROM jobs j
                        LEFT JOIN customers c ON j.customer_id = c.id
                        WHERE j.created_at BETWEEN ? AND ? AND j.store_id = ?
                        ORDER BY j.created_at DESC
                    """
                    export_params = [start_date_str, end_date_str, user['store_id']]
                    
                else:  # technician
                    export_query = """
                        SELECT j.*, c.name as customer_name, ta.assigned_at, ta.status as assignment_status
                        FROM jobs j
                        LEFT JOIN customers c ON j.customer_id = c.id
                        JOIN assignment_jobs aj ON j.id = aj.job_id
                        JOIN technician_assignments ta ON aj.assignment_id = ta.id
                        WHERE ta.technician_id = ? AND ta.assigned_at BETWEEN ? AND ?
                        ORDER BY ta.assigned_at DESC
                    """
                    export_params = [user['id'], start_date_str, end_date_str]
                
                export_data = pd.read_sql(export_query, conn, params=export_params)
                
                if not export_data.empty:
                    csv_buffer = io.StringIO()
                    export_data.to_csv(csv_buffer, index=False)
                    csv_data = csv_buffer.getvalue()
                    
                    filename = f"RepairPro_Data_{user['role']}_{start_date_str}_to_{end_date_str}.csv"
                    
                    st.success("‚úÖ Data exported successfully!")
                    st.download_button(
                        label="‚¨áÔ∏è Download CSV Data",
                        data=csv_data,
                        file_name=filename,
                        mime="text/csv",
                        key="raw_data_export"
                    )
                else:
                    st.warning("No data available for export in the selected period.")
                    
            except Exception as e:
                st.error(f"Error exporting data: {str(e)}")
    
    with col3:
        if st.button("üìä Quick Summary"):
            try:
                # Generate quick summary based on role
                if user['role'] == 'admin':
                    summary_query = """
                        SELECT 
                            COUNT(*) as total_jobs,
                            COUNT(DISTINCT store_id) as stores,
                            COUNT(DISTINCT customer_id) as customers,
                            SUM(CASE WHEN status = 'Completed' THEN actual_cost ELSE 0 END) as revenue
                        FROM jobs 
                        WHERE created_at BETWEEN ? AND ?
                    """
                    summary_params = [start_date_str, end_date_str]
                    
                elif user['role'] == 'manager':
                    summary_query = """
                        SELECT 
                            COUNT(*) as total_jobs,
                            COUNT(DISTINCT customer_id) as customers,
                            SUM(CASE WHEN status = 'Completed' THEN actual_cost ELSE 0 END) as revenue
                        FROM jobs 
                        WHERE created_at BETWEEN ? AND ? AND store_id = ?
                    """
                    summary_params = [start_date_str, end_date_str, user['store_id']]
                    
                else:  # technician
                    summary_query = """
                        SELECT 
                            COUNT(DISTINCT aj.job_id) as jobs_handled,
                            SUM(CASE WHEN j.status = 'Completed' THEN j.actual_cost ELSE 0 END) as revenue_generated
                        FROM technician_assignments ta
                        JOIN assignment_jobs aj ON ta.id = aj.assignment_id
                        JOIN jobs j ON aj.job_id = j.id
                        WHERE ta.technician_id = ? AND ta.assigned_at BETWEEN ? AND ?
                    """
                    summary_params = [user['id'], start_date_str, end_date_str]
                
                summary = pd.read_sql(summary_query, conn, params=summary_params).iloc[0]
                
                # Display quick summary
                st.success("üìä Quick Summary Generated!")
                for key, value in summary.items():
                    if 'revenue' in key.lower():
                        st.info(f"**{key.replace('_', ' ').title()}**: ‚Çπ{value:,.2f}")
                    else:
                        st.info(f"**{key.replace('_', ' ').title()}**: {value:,}")
                        
            except Exception as e:
                st.error(f"Error generating summary: {str(e)}")


    
